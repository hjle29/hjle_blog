---
title: '반복적인 권한 체크, if문 대신 어노테이션 한 줄로 해결한 경험'
date: '2024-12-02'
tags: ['java', 'aop', 'annotation', 'security', 'validation']
summary: 어노테이션으로 반복적인 권한체크
description: '반복적인 권한 체크, if문 대신 어노테이션 한 줄로 해결한 경험'
---

### 1. 배경: '성장하는 서비스' 뒤에 숨겨진 보안 부채

제가 담당한 플랫폼은 수많은 사용자가 각자의 데이터를 관리하는 백오피스 환경이었습니다. 이런 구조에서는 각 입점사가 본인의 데이터에만 접근할 수 있도록 보장하는 **Data Isolation(데이터 격리)**이 필수적입니다.

서비스 규모가 커지고 API 개수가 늘어남에 따라, 개발자로서 다음과 같은 **불안감**과 **비효율**을 마주하게 되었습니다. 백오피스 특성상 접근할 수 없는 데이터가 노출되는 거나 이를 넘어 수정되는 것은 단순한 버그를 넘어 서비스의 신뢰도와 직결되는 치명적인 보안 사고입니다. 하지만 매번 수동으로 검증 로직을 작성하다 보니 다음과 같은 한계에 부딪혔습니다.

- **코드 중복:** 수백 개의 API 마다 세션의 데이터와 요청 파라미터의 데이터를 비교하는 동일한 `if` 문이 반복되었습니다.
- **높은 인적 실수 가능성:** 개발자가 실수로 체크 로직을 누락할 경우, **IDOR(부적절한 직접 객체 참조)** 보안 사고로 직결될 위험이 있었습니다.

이러한 **'수동 검증의 굴레'**에서 벗어나, 시스템적으로 보안을 보장할 수 있는 구조를 고민하기 시작했습니다

---

## 2. 해결책: AOP를 활용한 선언적 권한 검증

### [Step 1] 서비스 진입점: AOP를 활용한 선언적 권한 검증

가장 먼저 해결하고 싶었던 것은 **코드 중복**이었습니다.

**WHY?**

- 권한 검증은 비즈니스 로직이 아닌 '공통 관심사(Cross-cutting Concerns)'입니다. 이를 컨트롤러나 서비스 로직에서 분리해 \**`@CheckDataAuthority`*라는 어노테이션 하나로 해결하고 싶었습니다.

**RESULT**

- Aspect에서 세션의 계정 정보와 요청 파라미터를 가로채 비교함으로써, 개발자는 보안 걱정 없이 비즈니스 로직 구현에만 집중할 수 있게 되었습니다.

### [Step 2] 데이터 조작 단계: DB 기반의 최종 무결성 검증

하지만 API 파라미터로 넘어온 값은 언제든 위조될 가능성이 있습니다. 계정과 관련된 정보 이외에도 다른 DB의 KEY 로 사용된 데이터가 조작되는 경우, 이를 방지하기 위해 실제 DB 데이터를 수정하기 직전, **'2차 방어선'**을 구축했습니다.

- **구현**: Backend API 로직 내에서 수정할 대상을 DB에서 먼저 조회한 뒤, 조회된 데이터에 담긴 데이터 실제 현재 로그인한 계정의 정보가 접근 가능한 데이터인지 한 번 더 확인합니다.
- **의도**: 설령 외부에서 파라미터 조작을 시도하더라도, 실제 저장된 데이터의 주인과 일치하지 않으면 수정 자체가 불가능하도록 **데이터 무결성**을 확보했습니다.

"보안 로직을 비즈니스 로직에서 완전히 분리하자"는 목표를 세우고, **Java AOP(Aspect-Oriented Programming)**와 **Custom Annotation**을 결합한 해결책을 설계했습니다.

### 핵심 아이디어

1. *`@CheckDataAuthority`*라는 커스텀 어노테이션을 정의합니다.
2. 검증이 필요한 메서드에 이 어노테이션을 선언적으로 부착합니다.
3. **Aspect**에서 메서드 실행 전(`@Before`)에 세션 정보와 파라미터를 가로채 검증을 수행합니다.

## 3. 기술적 구현 디테일

---

### Custom Annotation 정의

메서드 레벨에서 동작하며 런타임까지 유지되도록 설정했습니다.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CheckDataAuthority {
    // 향후 권한 레벨이나 특정 필드명을 지정할 수 있도록 확장성을 고려했습니다.
}
```

### Aspect를 통한 검증 로직 통합

`JoinPoint`를 활용해 인입되는 DTO나 파라미터에서 확인해야 할 데이터를 를 동적으로 추출하고, 세션의 정보와 비교합니다.

```java
@Aspect
@Component
public class AuthorityAspect {

    @Before("@annotation(com.service.annotation.CheckDataAuthority)")
    public void validateDataAuthority(JoinPoint joinPoint) {
        // 1. 세션(SecurityContext)에서 현재 로그인한 사용자의 고유 ID 추출
        String sessionId = SecurityUtil.getCurrentId();

        // 2. 메서드 파라미터에서 요청된 데이터의 소유권 ID(예: Id) 추출
        Object[] args = joinPoint.getArgs();
        String requestId = extractId(args);

        // 3. 데이터 소유권 일치 여부 검증
        if (requestId != null && !requestId.equals(sessionId)) {
            throw new AccessDeniedException("해당 데이터에 대한 접근 권한이 없습니다.");
        }
    }

    private String extractId(Object[] args) {
        // 파라미터 내 DTO나 String에서 ID를 찾는 유틸 로직
        // ...
    }
}
```

---

## 4. 결과 및 성과

이 구조를 도입한 후, 플랫폼 전체에 유의미한 변화가 나타났습니다.

- **생산성 향상:** 반복되는 보안 코드를 한 곳으로 모듈화하면서, 개별 컨트롤러의 보안 관련 코드 양을 **80% 이상 감소**시켰습니다.
- **유지보수의 단일화:** 보안 정책이 바뀌더라도 수백 개의 코드를 뒤질 필요가 없습니다. 이제 `AuthorityAspect` 한 곳만 수정하면 전체 서비스에 즉시 반영됩니다.
- **보안 안정성 강화:** 개발자는 어노테이션 한 줄만 추가하면 됩니다. '깜빡하는 실수'가 끼어들 틈이 사라졌고, 결과적으로 IDOR 취약점을 원천 차단하는 환경을 구축했습니다.

### 마치며

처음에는 제가 담당한 모듈에서 반복되는 `if` 문이 보기 싫어 시작한 작은 고민이었습니다. "어떻게 하면 조금 더 안전하고 편하게 개발할 수 있을까?"라는 고민으로 시작한 작어이었습니다.

막상 구현하고 보니 이 검증 로직은 플랫폼 전체에 꼭 필요한 공통 요소였습니다. 결국 팀 내 다른 모듈들에도 이 방식을 전파하게 되었고, 동료들의 업무 효율까지 높여주는 결과로 이어졌습니다. 제가 만든 구조가 동료들에게 도움이 되는 것을 보며, 개발자로서 가장 큰 보람을 느꼈던 경험이었습니다.
