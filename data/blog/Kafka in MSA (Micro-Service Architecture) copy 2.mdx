---
title: 'Kafka in MSA (Micro-Service Architecture)'
date: '2025-12-30'
tags: ['java', 'cloud', 'msa', 'transaction', 'db']
summary: Kafka in MSA (Micro-Service Architecture)
description: 'Kafka in MSA (Micro-Service Architecture)'
---

## 회원가입

### MEMBER-API

회원가입 관련 DB 처리를 한 후 한 트랜잭션 내에서 쿠폰 발급을 위한 ORDER-API 를 호출한다.

이 때, ORDER-API 에서는 회원 정보를 읽어올 수 없기 때문에 사용자의 등급을 알 수 없기 때문에 전달받은 mbrNo, promoNo 에 대한 중복 확인 후 발급 처리만 가능하다.

`트랜잭션 격리 수준이 동일 DB 세션 내에서만 유지되기 때문`

## 주문

주문을 처리하는 과정에서 예외가 발생하면 rollbackProcess를 통해 외부 API 호출에 대한 Rollback 프로세스를 호출하게 된다.

하지만, 주문 처리 과정에서 ORDER-API 자체가 종료되면, rollback 프로세스를 실행하지 않기 때문에 API 끼리의 데이터 정합성이 어긋난다.

## Kafka 가 필요한 이유

- 트랜잭션의 격리 수준을 `세션 기반`이 아닌 `시스템 전체`로 확장시킬 수 있다.
- 서비스가 강제로 종료된다고 하더라도, DB에 영속화된 아웃박스 기록을 통해 메시지 발행의 최종적 일관성(Eventual Consistency)을 보장할 수 있다.
- DB 변경 작업과 아웃박스의 기록이 하나의 트랜잭션으로 묶여서 관리되기 때문에 RollbackProcess를 간소화하는 효과를 가져올 수 있다.

`아웃박스의 기록에 대한 메세지 발행이 중복으로 발생할 수 있기 때문에 중복 처리에 대한 방어로직이 필요하다.`

## 📝 시스템 장애 상황에서의 데이터 격리 및 정합성 비교

### 1. 카프카를 사용하지 않을 때 (REST API 직접 호출)

이 방식은 **"내 서비스와 상대 서비스가 실시간으로 운명을 같이 하는"** 방식입니다.

- **예외 상황 (Exception):** \* 회원가입 도중 쿠폰 발급 API가 실패하면, 전체를 롤백(Rollback)하거나 복잡한 취소 API를 직접 호출해야 합니다.
- **시스템 강제 종료 (Crash):** \* 쿠폰 발급 API를 호출하기 직전이나 호출 도중 서버가 죽으면, DB는 롤백되지만 이미 날아간 API 요청은 취소할 방법이 없습니다. 데이터가 꼬일 확률이 매우 높습니다.
- **배포 상황:** \* 상대 서비스가 배포 중이라 응답을 못 하면, 내 서비스도 덩달아 에러가 나거나 무한 대기(Timeout)에 빠집니다.

---

### 2. 카프카를 사용했을 때 (아웃박스 패턴 + CDC)

이 방식은 **"내 DB에 기록만 되면, 나머지는 카프카가 책임지는"** 방식입니다.

- **예외 상황 (Exception):**
  - **비즈니스 로직(회원가입/주문)과 이벤트 기록(아웃박스)을 하나의 트랜잭션**으로 묶습니다.
  - 에러가 나면 두 기록이 함께 롤백되므로, 카프카로 메시지가 나갈 일 자체가 없어 데이터 격리가 완벽히 유지됩니다.
- **시스템 강제 종료 (Crash):**
  - DB에 커밋(Commit)이 된 후 서버가 죽더라도, **이벤트 기록은 DB에 영속화(Persist)**되어 남아있습니다.
  - 서버가 다시 살아나거나 CDC(Debezium 등)가 DB 로그를 읽어 나중에라도 카프카에 메시지를 쏘기 때문에 데이터는 결국 일치하게 됩니다.
- **배포 상황:**
  - 상대 서비스가 죽어있어도 메시지는 카프카에 안전하게 쌓입니다. 상대방은 배포가 끝나고 살아나는 즉시 메시지를 읽어 처리하므로 장애가 전파되지 않습니다.

---

| 상황               | 카프카 미사용 (직접 호출)         | 카프카 사용 (아웃박스 패턴)                   |
| ------------------ | --------------------------------- | --------------------------------------------- |
| **장애 시 정합성** | 일시적/영구적 불일치 위험 큼      | **최종적 일관성(Eventually Consistent)** 보장 |
| **복구 방식**      | 개발자가 수동 롤백 로직 구현      | **재시도(Retry)** 및 DB 로그 기반 자동 복구   |
| **격리 수준**      | 서비스 간 강한 결합으로 장애 전파 | 서비스 간 완전 격리로 독립적 운영 가능        |
