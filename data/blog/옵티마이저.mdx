---
title: '매출 조회 쿼리 개선 과정에서 확인한 DB 옵티마이저의 동작'
date: '2026-02-04'
tags: ['db', 'features', 'optimizer', 'SQL', 'query', 'big data']
summary: 옵티마이저의 동작
images: ['/static/images/data/optimizer.png']
description: '서브쿼리 필터링 위치 변경이 성능에 큰 차이를 주지 않았던 원인 분석'
---

# 매출 조회 쿼리 개선 과정에서 확인한 DB 옵티마이저의 동작

매출 내역 조회 기능의 성능 저하로 인해 쿼리 실행 계획을 검토하고 개선안을 테스트한 과정을 기록합니다.

## 1. 기존 쿼리 구조 및 문제 인식

기존 쿼리는 매출(+)과 취소 매출(-) 데이터를 각각 `UNION ALL`로 결합하는 구조였습니다. 구체적인 실행 흐름은 다음과 같았습니다.

1.  **집계**: 가장 데이터가 많은 '부가비용' 테이블을 주문번호와 주문순번 기준으로 `SUM` 집계.
2.  **조인**: 외부 쿼리에서 '주문 기본' 테이블과 조인.
3.  **필터링**: 자사 사이트 주문건만 남기도록 필터링.

### 예상했던 문제점

논리적인 구조상으로는 대량의 부가비용 데이터를 먼저 모두 집계한 뒤, 외부 조인을 거쳐 필터링이 일어난다고 판단했습니다. 따라서 필터링 조건을 서브쿼리 내부로 밀어 넣으면 집계 대상 데이터가 줄어들어 성능이 크게 개선될 것이라 생각했습니다.

## 2. 테스트 결과 및 의문점

가설에 따라 필터링 위치를 변경하여 테스트를 진행했으나, 예상과 달리 **유의미한 성능 차이가 발견되지 않았습니다.** 작성된 SQL의 순서대로라면 분명 연산량의 차이가 발생해야 함에도 결과가 동일한 원인을 분석한 결과, **데이터베이스 옵티마이저(Optimizer)**의 최적화 메커니즘을 확인하게 되었습니다.

## 3. DB 옵티마이저의 역할

사용자가 작성한 SQL은 실행의 목적(What)을 정의할 뿐, 실제 실행 순서(How)는 DB 옵티마이저가 결정합니다.

- **실행 계획 최적화**: 옵티마이저는 테이블 통계 정보를 바탕으로 가장 비용이 적은 경로를 선택합니다.
- **조건 절 푸시다운(Predicate Push-down)**: 제가 수동으로 옮기려 했던 필터링 조건은, 이미 옵티마이저가 쿼리 분석 단계에서 가장 효율적인 위치(서브쿼리 내부 등)로 옮겨서 실행하고 있었습니다.
- **결론**: 사용자가 SQL 구조를 논리적으로 어떻게 배치하든, 옵티마이저가 판단하기에 동일한 결과가 보장되는 더 빠른 경로가 있다면 실행 단계에서 이를 재구성합니다.

## 4. 학습한 점

- **가설 검증의 중요성**: 쿼리 튜닝 시 짐작만으로 구조를 변경하기보다, 실제 데이터와 환경에서 성능 차이를 측정하는 것이 우선되어야 함을 확인했습니다.
- **실행 계획(Explain Plan) 확인**: SQL 문법 자체보다 DB가 내부적으로 생성한 실행 계획을 분석하는 것이 성능 최적화의 핵심임을 깨달았습니다.

---

# 이 후에 공부한 것

### 1. 인덱스가 있을 때의 동작 (B-Tree 탐색)

인덱스는 책의 **'색인'**과 같습니다. 인덱스가 있으면 테이블 전체를 읽지 않고 **B-Tree 구조**를 따라 원하는 데이터의 위치(주소)만 빠르게 찾아냅니다.

- **동작:** 루트 노드 → 브랜치 노드 → 리프 노드 순으로 타고 내려가 데이터의 주소(RID)를 획득한 뒤, 실제 테이블 블록으로 점프하여 데이터를 가져옵니다.

### 2. 동등 조인(Equi Join) vs 범위 조인(Non-Equi Join)

- **동등 조인:** `=` 연산자를 사용하여 양쪽 테이블의 값이 정확히 일치하는 데이터를 찾는 방식입니다. (예: `A.id = B.id`)
- **범위 조인:** `<`, `>`, `BETWEEN` 등의 연산자를 사용하여 특정 범위에 속하는 데이터를 연결하는 방식입니다. (예: `A.date >= B.start_date`)
  - *참고:* **Hash Join**은 해시 함수 특성상 '동등 조인'에서만 사용할 수 있습니다.

### 3. 데이터 정렬 상태 확인법

데이터베이스 입장에서 "정렬되어 있다"는 것은 **인덱스가 해당 순서로 생성되어 있음**을 의미합니다.

- 테이블 자체는 무작위(Heap)로 저장되지만, 특정 컬럼에 인덱스가 있다면 옵티마이저는 그 데이터를 '정렬된 상태'로 간주하고 **Merge Join** 등을 고려합니다.
- `EXPLAIN` 결과에서 `Index Scan`이나 `Sort` 단계가 있다면 정렬을 활용하거나 수행 중인 것입니다.

### 5. 인덱스가 B-Tree인 이유

**어떤 데이터를 찾더라도 탐색 시간이 일정하고(O(log N)), 대량의 데이터에서도 성능 저하가 적기 때문**입니다.

- **균형(Balanced):** 데이터가 추가/삭제되어도 트리의 높이가 일정하게 유지됩니다.
- **범위 검색 유리:** 리프 노드들이 서로 연결되어 있어 특정 범위 데이터를 훑을 때 매우 빠릅니다. (Hash 인덱스는 범위 검색이 불가능합니다.)

### 6. 인덱스의 조건이란?

쿼리의 `WHERE` 절이나 `JOIN` 조건에 사용된 컬럼이 **인덱스의 구성과 일치하여 실제로 인덱스를 사용할 수 있는 상황**을 말합니다.

- 예: `(이름, 나이)` 결합 인덱스가 있는데 `나이`로만 검색하면 인덱스 조건을 만족하지 못해 인덱스를 못 쓸 수 있습니다. (인덱스의 왼쪽 우선 법칙)

데이터베이스 성능은 단순히 어떤 키워드를 쓰느냐보다 **'옵티마이저가 인덱스를 어떻게 타느냐'**와 **'데이터를 얼마나 스캔하느냐'**에 결정됩니다.

---

## 1. OR 조건

`OR`은 성능 최적화가 가장 까다로운 조건 중 하나입니다.

- **성능 저하 요인:** `OR`로 연결된 두 컬럼 중 하나라도 인덱스가 없으면, 옵티마이저는 전체 테이블 스캔(Full Table Scan)을 선택할 확률이 높습니다. 인덱스가 각각 있더라도 인덱스를 결합(Index Merge)하는 과정에서 비용이 발생합니다.
- **해결책:** `UNION ALL`을 사용하면 각 쿼리가 독립적으로 인덱스를 확실히 탈 수 있어 더 효율적인 경우가 많습니다.

---

## 2. EXISTS vs NOT EXISTS

이 조건들은 **세미 조인(Semi-join)** 방식으로 동작하며, 보통 성능이 우수합니다.

- **EXISTS:** 조건에 맞는 데이터를 **찾는 즉시 스캔을 중단**(Short-circuit)합니다. 따라서 데이터 존재 여부만 확인할 때 매우 빠릅니다.
- **NOT EXISTS:** 반대로 조건에 맞는 게 없는지 끝까지 확인해야 하므로 `EXISTS`보다는 느릴 수 있지만, 후술할 `NOT IN`보다는 훨씬 안전하고 빠릅니다.
- **특징:** 메인 쿼리의 결과가 많고 서브쿼리의 결과가 적을 때 유리합니다.

---

## 3. IN vs NOT IN

`IN`은 가독성이 좋지만 데이터 양과 분포에 따라 성능 편차가 큽니다.

- **IN:** 내부적으로는 `OR` 조건들의 집합이나 `JOIN`으로 변환되어 처리됩니다. 최신 DB에서는 서브쿼리와 함께 쓸 경우 `EXISTS`와 성능 차이가 거의 없도록 최적화되어 있습니다.
- **NOT IN (주의):** 성능상 가장 위험합니다.
  1. 인덱스를 활용하지 못하는 경우가 많습니다.
  2. 서브쿼리 결과에 `NULL`이 포함되어 있으면 결과가 나오지 않거나 예측 불가능하게 동작하므로, 대량의 데이터에서는 `NOT EXISTS`나 `LEFT JOIN` + `IS NULL` 조합을 권장합니다.

---

## 요약 및 비교

| 조건           | 성능 특징                                      | 추천 상황                            |
| -------------- | ---------------------------------------------- | ------------------------------------ |
| **OR**         | 인덱스 활용이 비효율적일 때가 많음             | 조건이 단순하고 데이터가 적을 때     |
| **EXISTS**     | 일치 항목 발견 시 즉시 종료 (빠름)             | 서브쿼리에 데이터가 있는지 확인할 때 |
| **NOT EXISTS** | 전체 확인이 필요하나 안정적임                  | 특정 데이터가 없는 행을 추출할 때    |
| **IN**         | 가독성이 좋으나 대량 데이터에서 불리할 수 있음 | 고정된 값의 목록을 필터링할 때       |
