---
title: '매출 조회 쿼리 개선 과정에서 확인한 DB 옵티마이저의 동작'
date: '2026-02-04'
tags: ['markdown', 'db', 'features', 'optimizer']
description: '서브쿼리 필터링 위치 변경이 성능에 큰 차이를 주지 않았던 원인 분석'
---

# 매출 조회 쿼리 개선 과정에서 확인한 DB 옵티마이저의 동작

매출 내역 조회 기능의 성능 저하로 인해 쿼리 실행 계획을 검토하고 개선안을 테스트한 과정을 기록합니다.

## 1. 기존 쿼리 구조 및 문제 인식

기존 쿼리는 매출(+)과 취소 매출(-) 데이터를 각각 `UNION ALL`로 결합하는 구조였습니다. 구체적인 실행 흐름은 다음과 같았습니다.

1.  **집계**: 가장 데이터가 많은 '부가비용' 테이블을 주문번호와 주문순번 기준으로 `SUM` 집계.
2.  **조인**: 외부 쿼리에서 '주문 기본' 테이블과 조인.
3.  **필터링**: 자사 사이트 주문건만 남기도록 필터링.

### 예상했던 문제점

논리적인 구조상으로는 대량의 부가비용 데이터를 먼저 모두 집계한 뒤, 외부 조인을 거쳐 필터링이 일어난다고 판단했습니다. 따라서 필터링 조건을 서브쿼리 내부로 밀어 넣으면 집계 대상 데이터가 줄어들어 성능이 크게 개선될 것이라 생각했습니다.

## 2. 테스트 결과 및 의문점

가설에 따라 필터링 위치를 변경하여 테스트를 진행했으나, 예상과 달리 **유의미한 성능 차이가 발견되지 않았습니다.** 작성된 SQL의 순서대로라면 분명 연산량의 차이가 발생해야 함에도 결과가 동일한 원인을 분석한 결과, **데이터베이스 옵티마이저(Optimizer)**의 최적화 메커니즘을 확인하게 되었습니다.

## 3. DB 옵티마이저의 역할

사용자가 작성한 SQL은 실행의 목적(What)을 정의할 뿐, 실제 실행 순서(How)는 DB 옵티마이저가 결정합니다.

- **실행 계획 최적화**: 옵티마이저는 테이블 통계 정보를 바탕으로 가장 비용이 적은 경로를 선택합니다.
- **조건 절 푸시다운(Predicate Push-down)**: 제가 수동으로 옮기려 했던 필터링 조건은, 이미 옵티마이저가 쿼리 분석 단계에서 가장 효율적인 위치(서브쿼리 내부 등)로 옮겨서 실행하고 있었습니다.
- **결론**: 사용자가 SQL 구조를 논리적으로 어떻게 배치하든, 옵티마이저가 판단하기에 동일한 결과가 보장되는 더 빠른 경로가 있다면 실행 단계에서 이를 재구성합니다.

## 4. 학습한 점

## 4. 학습한 점

- **가설 검증의 중요성**: 쿼리 튜닝 시 짐작만으로 구조를 변경하기보다, 실제 데이터와 환경에서 성능 차이를 측정하는 것이 우선되어야 함을 확인했습니다.
- **실행 계획(Explain Plan) 확인**: SQL 문법 자체보다 DB가 내부적으로 생성한 실행 계획을 분석하는 것이 성능 최적화의 핵심임을 깨달았습니다.

---
